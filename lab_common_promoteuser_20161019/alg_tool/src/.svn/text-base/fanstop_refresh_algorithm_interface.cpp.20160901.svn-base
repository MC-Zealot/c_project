#include "fanstop_refresh_algorithm_interface.h"

DYN_ALGORITHMS(FansTopRefreshAlgorithmInterface);

int FansTopRefreshAlgorithmInterface::algorithm_core(uint64_t req_id, const AccessStr& access_str,
				VEC_CAND& vec_cand){
			
	//		LOG_ERROR("FansTopRefreshAlgorithmInterface::algorithm_core return 1\n");
			return 1;
		}
		
int FansTopRefreshAlgorithmInterface::algorithm_core_new(uint64_t req_id, const AccessInfo* access_info, 
				const VEC_CAND& input_vec, VEC_CAND& output_vec){
	ACCESS_INFO* ai = (ACCESS_INFO*) access_info;
	int size = input_vec.size();
	
	LOG_ERROR(" AccessInfo come_uid:%lu,load_bhv:%s\n",ai->come_uid,ai->load_bhv.c_str());

	if(std::atoi(ai->load_bhv.c_str()) > 0){
		LOG_ERROR("load_bhv success! load_bhv:%s\n",ai->load_bhv.c_str());
	}
	if(std::atoi(ai->load_bhv.c_str()) < size && std::atoi(ai->load_bhv.c_str()) > 0){
		VEC_CAND::const_iterator it = input_vec.begin();
		FANSTOP_CAND_ADS *final = (FANSTOP_CAND_ADS*)(*it);
		time_t tmiestamp = final->createtime;
		uint16_t type = final->paid_type;
		for(;it != input_vec.end(); ++it){
			FANSTOP_CAND_ADS * ft = (FANSTOP_CAND_ADS*)(*it);
			if(ft->paid_type > type){
				type = ft->paid_type;
				tmiestamp = ft->createtime;
				final = ft;
			}else if(ft->paid_type == type){
				if(ft->createtime < tmiestamp){
					tmiestamp = ft->createtime;
					final = ft;
				}
			}
		//	LOG_ERROR("FansTopRefreshAlgorithmInterface,output_vec->time::%d\n",final->createtime);	
		}
		LOG_ERROR("back_refresh success! cand_num:%d,load_bhv:%s\n",size,ai->load_bhv.c_str());
		output_vec.push_back(final);
	}
	return 1;
}
