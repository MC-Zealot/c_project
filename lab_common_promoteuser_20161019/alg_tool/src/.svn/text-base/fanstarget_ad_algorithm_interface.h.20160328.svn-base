#ifndef _FANSTARGET_AD_ALGORITHM_INTERFACE_HEADER_
#define _FANSTARGET_AD_ALGORITHM_INTERFACE_HEADER_

#include "algorithm_interface.h"
#include "fanstarget_ad.h"

const uint32_t MAX_FREQUENCY = 15; //看广告保护阈值
const uint32_t MIN_FREQUENCY = 1;  //看广告补投阈值
const uint64_t BUY_THRESHOLD = 3000;  // 订单补投阈值
const uint64_t FLOW_AMOUNT = 54166;	//每5min 可以用来补投的流量
const double BUY_OCCUPY_MAX_PACKAGE = 0.35f;  //需要调研确定的数据 
const double TIME_WEIGHT[] = { 0.71, 0.79, 1.11, 0.89, 1.16, 1.41, 1.31, 1.19,
    1.35, 1.12, 1.44, 1.24, 1.37, 1.52, 1.52, 1.75,
	    1.68, 0.74, 0.41, 0.25, 0.2, 0.17, 0.24, 0.43 };

class FansTargetAlgorithmInterface : public AlgorithmInterface
{
	public:

		FANS_TAR_AD *fansAdThread[4];
		VEC_CAND fans_ad_vec_thread;
		FansTargetAlgorithmInterface(DbCompany*& p_db_company, int interface_id):
			AlgorithmInterface(p_db_company, interface_id)
		{
			LOG_ERROR("init FansTargetAlgorithmInterface.");
			
			time_t now;
			time(&now);

			for(int i = 0;i < 4; i ++){
				fansAdThread[i] = new FANS_TAR_AD();
				fansAdThread[i]->type = 1;
				fansAdThread[i]->field_id = "0";
				fansAdThread[i]->bridge_uid = 0;
				fansAdThread[i]->buy_amount = 1000;
				fansAdThread[i]->max_package = 2000;
				fansAdThread[i]->finish_amount = 500;
				fansAdThread[i]->begin_time = now;
				fansAdThread[i]->ad_type = 2;
				fansAdThread[i]->brg_type = 1;

				fans_ad_vec_thread.push_back(fansAdThread[i]);
			}
		}

		~FansTargetAlgorithmInterface() {
			LOG_ERROR("destroy FansTargetAlgorithmInterface.");
			for(int i = 0;i < 4; i ++){
				delete(fansAdThread[i]);
			}
		}

	public:
		int algorithm_core(uint64_t req_id,const AccessStr& access_str, VEC_CAND& vec_cand);
		int algorithm_core_new(uint64_t req_id, const AccessInfo* access_info, const VEC_CAND& input_vec, VEC_CAND& output_vec);
		int slow_order(VEC_CAND& cand_ids,VEC_CAND& output_vec);
		double get_random();
		int supply_order(uint16_t num,uint32_t flag,VEC_CAND& input_vec,VEC_CAND& output_vec);//补足订单数目
		int algorithm_log(VEC_CAND& output_vec,uint16_t return_type,uint16_t num);	//返回算法层日志
		int so_consume_time(struct timeval& start);	//统计插件花费时间
		int high_quality_user(uint64_t uid, VEC_CAND& input_vec, VEC_CAND& output_vec);	//永生优质流量
};


#endif
